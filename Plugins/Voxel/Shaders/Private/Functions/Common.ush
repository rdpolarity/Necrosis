// Copyright Voxel Plugin, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../ViewUtils.ush"

float2 GetTexCoords(FMaterialPixelParameters Parameters, int Index)
{
#if NUM_MATERIAL_TEXCOORDS_VERTEX
	return Index >= NUM_MATERIAL_TEXCOORDS_VERTEX ? float2(0, 0) : Parameters.TexCoords[Index];
#else
	return float2(0, 0);
#endif
}

int2 GetCubicGreedyUVs(FMaterialPixelParameters Parameters, const int IndexOffset, const int TextureSizeX)
{
	const int2 TexCoord = floor(GetTexCoords(Parameters, 0));
	
#if VOXEL_CUBIC_GREEDY
	const int2 TextureIndexAndQuadWidth = floor(GetTexCoords(Parameters, 1));
	check(all(TextureIndexAndQuadWidth == GetTexCoords(Parameters, 1)));

	const int TextureIndex = TextureIndexAndQuadWidth.x;
	const int QuadWidth = TextureIndexAndQuadWidth.y;
#else
	const int4 VertexColor = round(Parameters.VertexColor * 255);

	const uint PackedData =
		(uint(VertexColor.x) << 0 ) |
		(uint(VertexColor.y) << 8 ) |
		(uint(VertexColor.z) << 16) |
		(uint(VertexColor.w) << 24);
	
	const int TextureIndex = PackedData & ((1 << 26) - 1);
	const int QuadWidth = PackedData >> 26;
#endif
	
	const int Index = IndexOffset + TextureIndex + (TexCoord.x + TexCoord.y * QuadWidth);
	const int Y = Index / TextureSizeX;
	const int X = Index  - Y * TextureSizeX;
	
	return int2(X, Y);
}

float GetSceneDepthFromRayHit(float3 Position)
{
    float4 ScreenPosition = mul(float4(Position, 1.0f), GetWorldToClip());

	FLATTEN
	if (View.ViewToClip[3][3] < 1.0f)
	{
		// Perspective 
	    return ScreenPosition.w;
	}
	else
	{
		// Ortho
		return ConvertFromDeviceZ(ScreenPosition.z);
	}
}

FLWCVector3 GetWorldPosition_NoMaterialOffsets(FMaterialVertexParameters Parameters)
{
	return GetWorldPosition(Parameters);
}