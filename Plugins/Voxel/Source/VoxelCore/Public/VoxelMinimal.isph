// Copyright Voxel Plugin, Inc. All Rights Reserved.

#pragma once

// ReSharper disable CppCStyleCast

#define INTELLISENSE_PARSER __INTELLISENSE__ || __RESHARPER__

#if INTELLISENSE_PARSER
#define INTELLISENSE_ONLY(...) __VA_ARGS__
#define varying
#define uniform
#define export
#define foreach(...)
#define assume(...) (void)!!(__VA_ARGS__)
#define assert(...) (void)!!(__VA_ARGS__)
#define VOXEL_DEBUG 1
#define TARGET_WIDTH 8

#define FOREACH(Var, Start, End) for (int32 Var = Start; Var < End; Var++)
#define UNROLL
#define UNROLL_N(N)
#define IGNORE_PERF_WARNING

#define MakeRegister(A, B, C, D, E, F, G, H) ((void)(A),(void)(B),(void)(C),(void)(D),(void)(E),(void)(F),(void)(G),(H))

using int8 = char;
using int16 = short;
using int32 = int;
using int64 = long long int;

using uint8 = unsigned char;
using uint16 = unsigned short;
using uint32 = unsigned int;
using uint64 = unsigned long long int;

struct float16
{
	float x;
	float y;
};

float min(float, float);
int32 min(int32, int32);
float max(float, float);
int32 max(int32, int32);
float clamp(float value, float a, float b);
int32 clamp(int32 value, int32 a, int32 b);

bool isnan(float16 v);
bool isnan(float v);
bool isnan(double v);

int8 rotate(int8 value, int offset);
int16 rotate(int16 value, int offset);
int32 rotate(int32 value, int offset);
int64 rotate(int64 value, int offset);
float16 rotate(float16 value, int offset);
float rotate(float value, int offset);
double rotate(double value, int offset);

int8 shuffle(int8 value, int permutation);
int16 shuffle(int16 value, int permutation);
int32 shuffle(int32 value, int permutation);
int64 shuffle(int64 value, int permutation);
float16 shuffle(float16 value, int permutation);
float shuffle(float value, int permutation);
double shuffle(double value, int permutation);

bool any(bool v);
bool all(bool v);
bool none(bool v);

int16 reduce_add(int8 x);
uint16 reduce_add(uint8 x);
int32 reduce_add(int16 x);
uint32 reduce_add(uint16 x);
int64 reduce_add(int32 x);
uint64 reduce_add(uint32 x);
int64 reduce_add(int64 x);
uint64 reduce_add(uint64 x);

float16 reduce_add(float16 x);
float reduce_add(float x);
double reduce_add(double x);

int32 reduce_min(int32 a);
uint32 reduce_min(uint32 a);
int64 reduce_min(int64 a);
uint64 reduce_min(uint64 a);

float16 reduce_min(float16 a);
float reduce_min(float a);
double reduce_min(double a);

int32 reduce_max(int32 a);
uint32 reduce_max(uint32 a);
int64 reduce_max(int64 a);
uint64 reduce_max(uint64 a);

float16 reduce_max(float16 a);
float reduce_max(float a);
double reduce_max(double a);

bool reduce_equal(int32 v);
bool reduce_equal(uint32 v);
bool reduce_equal(int64 v);
bool reduce_equal(uint64 v);

bool reduce_equal(float16 v);
bool reduce_equal(float v);
bool reduce_equal(double);

bool reduce_equal(int32 v, int32* sameval);
bool reduce_equal(uint32 v, uint32* sameval);
bool reduce_equal(int64 v, int64* sameval);
bool reduce_equal(uint64 v, uint64* sameval);

bool reduce_equal(float16 v, float16* sameval);
bool reduce_equal(float v, float* sameval);
bool reduce_equal(double, double* sameval);

int32 exclusive_scan_add(int32 v);
uint32 exclusive_scan_add(uint32 v);
float16 exclusive_scan_add(float16 v);
float exclusive_scan_add(float v);
int64 exclusive_scan_add(int64 v);
uint64 exclusive_scan_add(uint64 v);
double exclusive_scan_add(double v);
int32 exclusive_scan_and(int32 v);
uint32 exclusive_scan_and(uint32 v);
int64 exclusive_scan_and(int64 v);
uint64 exclusive_scan_and(uint64 v);
int32 exclusive_scan_or(int32 v);
uint32 exclusive_scan_or(uint32 v);
int64 exclusive_scan_or(int64 v);
uint64 exclusive_scan_or(uint64 v);

uniform bool extract(bool x, uniform int i);
uniform int8 extract(int8 x, uniform int i);
uniform int16 extract(int16 x, uniform int i);
uniform int32 extract(int32 x, uniform int i);
uniform int64 extract(int64 x, uniform int i);
uniform float16 extract(float16 x, uniform int i);
uniform float extract(float x, uniform int i);
uniform double extract(double x, uniform int i);

float abs(float value);
int32 abs(int32 value);
float pow(float base, float exp);
float sqrt(float value);
float rsqrt(float value);
float floor(float value);
float ceil(float value);
float round(float value);
float trunc(float x);

float cos(float value);
float acos(float value);
float sin(float value);
float asin(float value);
float tan(float value);
float atan(float value);
float atan2(float valuea, float valueb);
void sincos(float x, float* s, float* c);

float16 float16bits(uint16 a);
float16 float16bits(uint16 a);
float floatbits(uint32 a);
float floatbits(uint32 a);
double doublebits(uint64 a);
double doublebits(uint64 a);
uint16 intbits(float16 a);
uint16 intbits(float16 a);
uint32 intbits(float a);
uint32 intbits(float a);
uint64 intbits(double a);
uint64 intbits(double a);

int32 programCount;
int32 programIndex;

#error "Compiler defined as parser"
#else
#define INTELLISENSE_ONLY(...)
#define FOREACH(Var, Start, End) foreach (Var = Start ... End)
#define UNROLL #pragma unroll
#define UNROLL_N(N) UNROLL N
#define IGNORE_PERF_WARNING #pragma ignore warning(perf)

#if TARGET_WIDTH == 8
#define MakeRegister(A, B, C, D, E, F, G, H) { A, B, C, D, E, F, G, H }
#endif
#endif

#ifndef VOXEL_DEBUG
// VOXEL_DEBUG seems to not be defined when packaging plugin
#define VOXEL_DEBUG 0
//#error "VOXEL_DEBUG not defined"
#endif

#define FORCEINLINE inline

extern "C" void VoxelISPC_Assert(uniform int Line);

#if VOXEL_DEBUG
#define check(...) if (!(__VA_ARGS__)) { VoxelISPC_Assert(__LINE__); }
#define VOXEL_ASSUME(...) check(__VA_ARGS__)
#else
#define check(...)
#define VOXEL_ASSUME(...) assume((__VA_ARGS__))
#endif

#undef PI
#define PI 3.1415926535897932f
#define KINDA_SMALL_NUMBER 1.e-4f

FORCEINLINE float lerp(float A, float B, float Alpha)
{
	// Minimize float precision errors in case A or B is huge
	return A * (1.f - Alpha) + B * Alpha;
}

FORCEINLINE float fmod(float x, float y)
{
	return x - trunc(x / y) * y;
}

FORCEINLINE bool IsFinite(float A)
{
	return (intbits(A) & 0x7F800000U) != 0x7F800000U;
}

FORCEINLINE float InvSqrt(float X)
{
	return 1.f / sqrt(X);
}

FORCEINLINE float Square(float X)
{
	return X * X;
}

FORCEINLINE float SmoothStep(float A, float B, float Alpha)
{
	if (Alpha < A)
	{
		return 0.f;
	}
	else if (Alpha >= B)
	{
		return 1.f;
	}

	const float InterpFraction = (Alpha - A) / (B - A);
	return InterpFraction * InterpFraction * (3.0f - 2.0f * InterpFraction);
}

FORCEINLINE uint32 MurmurHash32(uint32 Hash)
{
	Hash ^= Hash >> 16;
	Hash *= 0x85ebca6b;
	Hash ^= Hash >> 13;
	Hash *= 0xc2b2ae35;
	Hash ^= Hash >> 16;
	return Hash;
}

#define MAX_uint8	0xff
#define MAX_uint16	0xffff
#define MAX_uint32	0xffffffff
#define MAX_uint64	0xffffffffffffffff
#define MAX_int8	0x7f
#define MAX_int16	0x7fff
#define MAX_int32	0x7fffffff
#define MAX_int64	0x7fffffffffffffff
#define MIN_flt		1.175494351e-38F
#define MAX_flt		3.402823466e+38F

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct float2
{
	float x;
	float y;
};
struct float3
{
	float x;
	float y;
	float z;
};
struct float4
{
	float x;
	float y;
	float z;
	float w;
};

struct int2
{
	int32 x;
	int32 y;
};
struct int3
{
	int32 x;
	int32 y;
	int32 z;
};
struct int4
{
	int32 x;
	int32 y;
	int32 z;
	int32 w;
};

#define float2_zero MakeFloat2(0, 0)
#define float3_zero MakeFloat3(0, 0, 0)
#define float4_zero MakeFloat4(0, 0, 0, 0)

#define int2_zero MakeInt2(0, 0)
#define int3_zero MakeInt3(0, 0, 0)
#define int4_zero MakeInt4(0, 0, 0, 0)

#define float2_one MakeFloat2(1, 1)
#define float3_one MakeFloat3(1, 1, 1)
#define float4_one MakeFloat4(1, 1, 1, 1)

#define int2_one MakeInt2(1, 1)
#define int3_one MakeInt3(1, 1, 1)
#define int4_one MakeInt4(1, 1, 1, 1)

FORCEINLINE float2 MakeFloat2(const float X, const float Y)
{
	float2 Result;
	Result.x = X;
	Result.y = Y;
	return Result;
}
FORCEINLINE float3 MakeFloat3(const float X, const float Y, const float Z)
{
	float3 Result;
	Result.x = X;
	Result.y = Y;
	Result.z = Z;
	return Result;
}
FORCEINLINE float4 MakeFloat4(const float X, const float Y, const float Z, const float W)
{
	float4 Result;
	Result.x = X;
	Result.y = Y;
	Result.z = Z;
	Result.w = W;
	return Result;
}

FORCEINLINE int2 MakeInt2(const int32 X, const int32 Y)
{
	int2 Result;
	Result.x = X;
	Result.y = Y;
	return Result;
}
FORCEINLINE int3 MakeInt3(const int32 X, const int32 Y, const int32 Z)
{
	int3 Result;
	Result.x = X;
	Result.y = Y;
	Result.z = Z;
	return Result;
}
FORCEINLINE int4 MakeInt4(const int32 X, const int32 Y, const int32 Z, const int32 W)
{
	int4 Result;
	Result.x = X;
	Result.y = Y;
	Result.z = Z;
	Result.w = W;
	return Result;
}

#define VECTOR_OP(Type, OpOp, Op) \
	FORCEINLINE Type ## 2 OpOp(Type ## 2 A, Type ## 2 B) \
	{ \
	    Type ## 2 Result; \
		Result.x = A.x Op B.x; \
		Result.y = A.y Op B.y; \
	    return Result; \
	} \
	FORCEINLINE Type ## 3 OpOp(Type ## 3 A, Type ## 3 B) \
	{ \
	    Type ## 3 Result; \
		Result.x = A.x Op B.x; \
		Result.y = A.y Op B.y; \
		Result.z = A.z Op B.z; \
	    return Result; \
	} \
	FORCEINLINE Type ## 4 OpOp(Type ## 4 A, Type ## 4 B) \
	{ \
	    Type ## 4 Result; \
		Result.x = A.x Op B.x; \
		Result.y = A.y Op B.y; \
		Result.z = A.z Op B.z; \
		Result.w = A.w Op B.w; \
	    return Result; \
	}

#define SCALAR_VECTOR_OP(InputType, ScalarType, ResultType, OpOp, Op) \
	FORCEINLINE ResultType ## 2 OpOp(InputType ## 2 A, ScalarType B) \
	{ \
	    ResultType ## 2 Result; \
		Result.x = A.x Op B; \
		Result.y = A.y Op B; \
	    return Result; \
	} \
	FORCEINLINE ResultType ## 3 OpOp(InputType ## 3 A, ScalarType B) \
	{ \
	    ResultType ## 3 Result; \
		Result.x = A.x Op B; \
		Result.y = A.y Op B; \
		Result.z = A.z Op B; \
	    return Result; \
	} \
	FORCEINLINE ResultType ## 4 OpOp(InputType ## 4 A, ScalarType B) \
	{ \
	    ResultType ## 4 Result; \
		Result.x = A.x Op B; \
		Result.y = A.y Op B; \
		Result.z = A.z Op B; \
		Result.w = A.w Op B; \
	    return Result; \
	} \
	\
	FORCEINLINE ResultType ## 2 OpOp(ScalarType A, InputType ## 2 B) \
	{ \
	    ResultType ## 2 Result; \
		Result.x = A Op B.x; \
		Result.y = A Op B.y; \
	    return Result; \
	} \
	FORCEINLINE ResultType ## 3 OpOp(ScalarType A, InputType ## 3 B) \
	{ \
	    ResultType ## 3 Result; \
		Result.x = A Op B.x; \
		Result.y = A Op B.y; \
		Result.z = A Op B.z; \
	    return Result; \
	} \
	FORCEINLINE ResultType ## 4 OpOp(ScalarType A, InputType ## 4 B) \
	{ \
	    ResultType ## 4 Result; \
		Result.x = A Op B.x; \
		Result.y = A Op B.y; \
		Result.z = A Op B.z; \
		Result.w = A Op B.w; \
	    return Result; \
	}

VECTOR_OP(float, operator*, *);
VECTOR_OP(float, operator/, /);
VECTOR_OP(float, operator+, +);
VECTOR_OP(float, operator-, -);

VECTOR_OP(int, operator*, *);
// Slow VECTOR_OP(int, operator/, /);
VECTOR_OP(int, operator+, +);
VECTOR_OP(int, operator-, -);

SCALAR_VECTOR_OP(float, float, float, operator*, *);
SCALAR_VECTOR_OP(float, float, float, operator/, /);
SCALAR_VECTOR_OP(float, float, float, operator+, +);
SCALAR_VECTOR_OP(float, float, float, operator-, -);

SCALAR_VECTOR_OP(int, int32, int, operator*, *);
// Slow SCALAR_VECTOR_OP(int, int32, int, operator/, /);
SCALAR_VECTOR_OP(int, int32, int, operator+, +);
SCALAR_VECTOR_OP(int, int32, int, operator-, -);

SCALAR_VECTOR_OP(int, float, float, operator*, *);
SCALAR_VECTOR_OP(int, float, float, operator/, /);
SCALAR_VECTOR_OP(int, float, float, operator+, +);
SCALAR_VECTOR_OP(int, float, float, operator-, -);

#undef VECTOR_OP
#undef SCALAR_VECTOR_OP

FORCEINLINE float2 MakeFloat2(const int2 Value)
{
	float2 Result;
	Result.x = Value.x;
	Result.y = Value.y;
	return Result;
}
FORCEINLINE float3 MakeFloat3(const int3 Value)
{
	float3 Result;
	Result.x = Value.x;
	Result.y = Value.y;
	Result.z = Value.z;
	return Result;
}

FORCEINLINE int2 MakeInt2(const float2 Value)
{
	int2 Result;
	Result.x = Value.x;
	Result.y = Value.y;
	return Result;
}
FORCEINLINE int3 MakeInt3(const float3 Value)
{
	int3 Result;
	Result.x = Value.x;
	Result.y = Value.y;
	Result.z = Value.z;
	return Result;
}

FORCEINLINE float2 floor(float2 Value)
{
	return MakeFloat2(
		floor(Value.x),
		floor(Value.y));
}
FORCEINLINE float3 floor(float3 Value)
{
	return MakeFloat3(
		floor(Value.x),
		floor(Value.y),
		floor(Value.z));
}

FORCEINLINE float2 clamp(float2 Value, float2 A, float2 B)
{
	return MakeFloat2(
		clamp(Value.x, A.x, B.x),
		clamp(Value.y, A.y, B.y));
}
FORCEINLINE float3 clamp(float3 Value, float3 A, float3 B)
{
	return MakeFloat3(
		clamp(Value.x, A.x, B.x),
		clamp(Value.y, A.y, B.y),
		clamp(Value.z, A.z, B.z));
}

FORCEINLINE int2 clamp(int2 Value, int2 A, int2 B)
{
	return MakeInt2(
		clamp(Value.x, A.x, B.x),
		clamp(Value.y, A.y, B.y));
}
FORCEINLINE int3 clamp(int3 Value, int3 A, int3 B)
{
	return MakeInt3(
		clamp(Value.x, A.x, B.x),
		clamp(Value.y, A.y, B.y),
		clamp(Value.z, A.z, B.z));
}

FORCEINLINE float length(const float2 Value)
{
	return sqrt(Value.x * Value.x + Value.y * Value.y);
}
FORCEINLINE float length(const float3 Value)
{
	return sqrt(Value.x * Value.x + Value.y * Value.y + Value.z * Value.z);
}

FORCEINLINE float distance(const float2 A, const float2 B)
{
	return length(B - A);
}
FORCEINLINE float distance(const float3 A, const float3 B)
{
	return length(B - A);
}

FORCEINLINE float2 normalize(const float2 Vector)
{
	const float SquareSum = Vector.x * Vector.x + Vector.y * Vector.y;
	return Vector * InvSqrt(SquareSum);
}
FORCEINLINE float3 normalize(const float3 Vector)
{
	const float SquareSum = Vector.x * Vector.x + Vector.y * Vector.y + Vector.z * Vector.z;
	if (SquareSum == 0.f)
	{
		return MakeFloat3(0, 0, 1);
	}

	return Vector * InvSqrt(SquareSum);
}

FORCEINLINE float3 cross(const float3 A, const float3 B)
{
	return MakeFloat3(
		A.y * B.z - A.z * B.y,
		A.z * B.x - A.x * B.z,
		A.x * B.y - A.y * B.x
	);
}

FORCEINLINE float dot(const float2 A, const float2 B)
{
	return A.x * B.x + A.y * B.y;
}

FORCEINLINE float dot(const float3 A, const float3 B)
{
	return A.x * B.x + A.y * B.y + A.z * B.z;
}

FORCEINLINE float DistanceSquared(const float2 A, const float2 B)
{
	const float2 C = A - B;
	return dot(C, C);
}
FORCEINLINE float DistanceSquared(const float3 A, const float3 B)
{
	const float3 C = A - B;
	return dot(C, C);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct float4x4
{
	float M[16];
};

FORCEINLINE float3 MatrixTransformPosition(const float4x4 Matrix, const float3 Vector)
{
	return MakeFloat3(
		Matrix.M[0] * Vector.x + Matrix.M[4] * Vector.y + Matrix.M[8] * Vector.z + Matrix.M[12],
		Matrix.M[1] * Vector.x + Matrix.M[5] * Vector.y + Matrix.M[9] * Vector.z + Matrix.M[13],
		Matrix.M[2] * Vector.x + Matrix.M[6] * Vector.y + Matrix.M[10] * Vector.z + Matrix.M[14]);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

FORCEINLINE float SmoothHelper(float Value, float Smoothness)
{
#if 1 // Seems to work even when Smoothness == 0
	return Value / Smoothness;
#else
	return Smoothness == 0.f
		? Value < 0.f ? -1.f : 1.f
		: Value / Smoothness;
#endif
}

FORCEINLINE float SmoothMin(float DistanceA, float DistanceB, float Smoothness)
{
	const float H = clamp(0.5f + 0.5f * SmoothHelper(DistanceB - DistanceA, Smoothness), 0.0f, 1.0f);
	return lerp(DistanceB, DistanceA, H) - Smoothness * H * (1.0f - H);
}

FORCEINLINE float SmoothMax(float DistanceA, float DistanceB, float Smoothness)
{
	const float H = clamp(0.5f - 0.5f * SmoothHelper(DistanceB - DistanceA, Smoothness), 0.0f, 1.0f);
	return lerp(DistanceB, DistanceA, H) + Smoothness * H * (1.0f - H);
}

// Subtract DistanceB from DistanceA
// DistanceB should be negative/inverted
FORCEINLINE float SmoothSubtraction(float DistanceA, float DistanceB, float Smoothness)
{
	const float H = clamp(0.5f + 0.5f * SmoothHelper(DistanceB - DistanceA, Smoothness), 0.0f, 1.0f);
	return lerp(DistanceA, DistanceB, H) + Smoothness * H * (1.0f - H);
}

FORCEINLINE float BilinearInterpolation(float A, float B, float C, float D, float X, float Y)
{
	return lerp(lerp(A, B, X), lerp(C, D, X), Y);
}

FORCEINLINE float TrilinearInterpolation(
	float A, float B, float C, float D,
	float E, float F, float G, float H,
	float X, float Y, float Z)
{
	return lerp(
		BilinearInterpolation(A, B, C, D, X, Y),
		BilinearInterpolation(E, F, G, H, X, Y),
		Z);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
struct FVoxelOctahedron
{
	uint8 X;
	uint8 Y;
};

FORCEINLINE uint8 FloatToUINT8(float Float)
{
	return clamp((int32)floor(Float * 255.999f), 0, 255);
}
FORCEINLINE float UINT8ToFloat(uint8 Int)
{
	return Int / 255.f;
}

// H00
FORCEINLINE float HermiteP0(float T)
{
	return (1 + 2 * T) * Square(1 - T);
}
// H10
FORCEINLINE float HermiteD0(float T)
{
	return T * Square(1 - T);
}

// H01
FORCEINLINE float HermiteP1(float T)
{
	return Square(T) * (3 - 2 * T);
}
// H11
FORCEINLINE float HermiteD1(float T)
{
	return Square(T) * (T - 1);
}

FORCEINLINE float2 UnitVectorToOctahedron(float3 Unit)
{
	const float AbsSum = abs(Unit.x) + abs(Unit.y) + abs(Unit.z);
	Unit.x /= AbsSum;
	Unit.y /= AbsSum;

	float2 Result = MakeFloat2(Unit.x, Unit.y);
	if (Unit.z <= 0)
	{
		Result.x = (1 - abs(Unit.y)) * (Unit.x >= 0 ? 1 : -1);
		Result.y = (1 - abs(Unit.x)) * (Unit.y >= 0 ? 1 : -1);
	}
	return Result * 0.5f + 0.5f;
}
FORCEINLINE float3 OctahedronToUnitVector(float2 Octahedron)
{
	Octahedron = Octahedron * 2.f - 1.f;

	float3 Unit;
	Unit.x = Octahedron.x;
	Unit.y = Octahedron.y;
	Unit.z = 1.f - abs(Octahedron.x) - abs(Octahedron.y);

	const float T = max(-Unit.z, 0.f);

	Unit.x += Unit.x >= 0 ? -T : T;
	Unit.y += Unit.y >= 0 ? -T : T;

	return normalize(Unit);
}

FORCEINLINE float3 OctahedronToUnitVector(FVoxelOctahedron Octahedron)
{
	return OctahedronToUnitVector(MakeFloat2(UINT8ToFloat(Octahedron.X), UINT8ToFloat(Octahedron.Y)));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

FORCEINLINE float4 MakeQuaternionFromEuler(float Pitch, float Yaw, float Roll)
{
	float SinPitch;
	float CosPitch;
	sincos(fmod(Pitch, 360.0f) * PI / 360.f, &SinPitch, &CosPitch);

	float SinYaw;
	float CosYaw;
	sincos(fmod(Yaw, 360.0f) * PI / 360.f, &SinYaw, &CosYaw);

	float SinRoll;
	float CosRoll;
	sincos(fmod(Roll, 360.0f) * PI / 360.f, &SinRoll, &CosRoll);

	return MakeFloat4(
		CosRoll * SinPitch * SinYaw - SinRoll * CosPitch * CosYaw,
		-CosRoll * SinPitch * CosYaw - SinRoll * CosPitch * SinYaw,
		CosRoll * CosPitch * SinYaw - SinRoll * SinPitch * CosYaw,
		CosRoll * CosPitch * CosYaw + SinRoll * SinPitch * SinYaw);
}
FORCEINLINE float4 MakeQuaternionFromBasis(const float3 X, const float3 Y, const float3 Z)
{
	float4 Quat;

	if (X.x + Y.y + Z.z > 0.0f)
	{
		const float InvS = InvSqrt(X.x + Y.y + Z.z + 1.0f);
		const float S = 0.5f * InvS;

		Quat.x = (Y.z - Z.y) * S;
		Quat.y = (Z.x - X.z) * S;
		Quat.z = (X.y - Y.x) * S;
		Quat.w = 0.5f * (1.f / InvS);
	}
	else if (X.x > Y.y && X.x > Z.z)
	{
		const float InvS = InvSqrt(X.x - Y.y - Z.z + 1.0f);
		const float S = 0.5f * InvS;

		Quat.x = 0.5f * (1.f / InvS);
		Quat.y = (X.y + Y.x) * S;
		Quat.z = (X.z + Z.x) * S;
		Quat.w = (Y.z - Z.y) * S;
	}
	else if (Y.y > X.x && Y.y > Z.z)
	{
		const float InvS = InvSqrt(Y.y - Z.z - X.x + 1.0f);
		const float S = 0.5f * InvS;

		Quat.y = 0.5f * (1.f / InvS);
		Quat.z = (Y.z + Z.y) * S;
		Quat.x = (Y.x + X.y) * S;
		Quat.w = (Z.x - X.z) * S;
	}
	else
	{
		const float InvS = InvSqrt(Z.z - X.x - Y.y + 1.0f);
		const float S = 0.5f * InvS;

		Quat.z = 0.5f * (1.f / InvS);
		Quat.x = (Z.x + X.z) * S;
		Quat.y = (Z.y + Y.z) * S;
		Quat.w = (X.y - Y.x) * S;
	}

	return Quat;
}
FORCEINLINE float4 MakeQuaternionFromZ(const float3 Z)
{
	const float3 NewZ = normalize(Z);

	// Try to use up if possible
	const float3 UpVector = abs(NewZ.z) < (1.f - KINDA_SMALL_NUMBER) ? MakeFloat3(0, 0, 1.f) : MakeFloat3(1.f, 0, 0);

	const float3 NewX = normalize(cross(UpVector, NewZ));
	const float3 NewY = cross(NewZ, NewX);

	return MakeQuaternionFromBasis(NewX, NewY, NewZ);
}